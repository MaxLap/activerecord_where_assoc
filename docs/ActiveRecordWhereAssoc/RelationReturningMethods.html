<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>module ActiveRecordWhereAssoc::RelationReturningMethods - activerecord_where_assoc</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../";
  var index_rel_prefix = "../";
</script>

<script src="../js/navigation.js" defer></script>
<script src="../js/search.js" defer></script>
<script src="../js/search_index.js" defer></script>
<script src="../js/searcher.js" defer></script>
<script src="../js/darkfish.js" defer></script>

<link href="../css/fonts.css" rel="stylesheet">
<link href="../css/rdoc.css" rel="stylesheet">
<link href="../docs_customization.css" rel="stylesheet">


<body id="top" role="document" class="module">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../table_of_contents.html#pages">Pages</a>
    <a href="../table_of_contents.html#classes">Classes</a>
    <a href="../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search (/) for a class, method, ..." spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  
<div class="nav-section">
  <h3>Table of Contents</h3>



  <ul class="link-list" role="directory">
              <li>      <a href="#module-ActiveRecordWhereAssoc::RelationReturningMethods-label-Association">Association</a>
          <li>      <a href="#module-ActiveRecordWhereAssoc::RelationReturningMethods-label-Condition">Condition</a>
          <li>      <a href="#module-ActiveRecordWhereAssoc::RelationReturningMethods-label-Block">Block</a>
          <li>
            <details open>
              <summary>      <a href="#module-ActiveRecordWhereAssoc::RelationReturningMethods-label-Options">Options</a>
</summary>
              <ul class="link-list" role="directory">
                          <li>      <a href="#module-ActiveRecordWhereAssoc::RelationReturningMethods-label-3Aignore_limit+option">:ignore_limit option</a>
          <li>      <a href="#module-ActiveRecordWhereAssoc::RelationReturningMethods-label-3Anever_alias_limit+option">:never_alias_limit option</a>
          <li>      <a href="#module-ActiveRecordWhereAssoc::RelationReturningMethods-label-3Apoly_belongs_to+option">:poly_belongs_to option</a>

              </ul>
            </details>
          </li>

  </ul>
</div>


  <div id="class-metadata">
    
<div id="sections-section" class="nav-section">
  <h3>Sections</h3>

  <ul class="link-list" role="directory">
      <li><a href="#5Buntitled-5D"></a></li>
      <li><a href="#Basic+methods">Basic methods</a></li>
      <li><a href="#Complex+method">Complex method</a></li>
  </ul>
</div>

    
    
    
    
<!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    <li ><a href="#method-i-where_assoc_count">#where_assoc_count</a>
    <li ><a href="#method-i-where_assoc_exists">#where_assoc_exists</a>
    <li ><a href="#method-i-where_assoc_not_exists">#where_assoc_not_exists</a>
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="module-ActiveRecordWhereAssoc::RelationReturningMethods">
  <h1 id="module-ActiveRecordWhereAssoc::RelationReturningMethods" class="module">
    module ActiveRecordWhereAssoc::RelationReturningMethods
  </h1>

  <section class="description">
    
<p>This module adds new variations of <code>#where</code> to your Models/relations/associations/scopes. These variations check if an association has records, so you can check if a <code>Post</code> has any <code>Comments</code>.</p>

<p>These variations return a new relation (just like <code>#where</code>) so you can chain them with other scoping methods such as <code>#where</code>, <code>#order</code>, <code>#limit</code>, more of these variations, etc.</p>

<p>The arguments common to all methods are documented here at the top.</p>

<p>For brevity, the examples are all directly on models, such as User, Post, Comment, but the methods are available and behave the same on:</p>
<ul><li>
<p>associations: <code>my_user.posts.where_assoc_exists(:comments)</code></p>
</li><li>
<p>relations: <code>Posts.where(serious: true).where_assoc_exists(:comments)</code></p>
</li><li>
<p>scopes: (On the Post model) <code>scope :with_comments, -&gt; { where_assoc_exists(:comments) }</code></p>
</li><li>
<p>models: <code>Post.where_assoc_exists(:comments)</code></p>
</li></ul>

<p>In short: Anywhere you could use #where, you can also use the methods presented here. This includes with ActiveRecord’s #or method.</p>

<p><a href="https://github.com/MaxLap/activerecord_where_assoc/blob/master/INTRODUCTION.md">Introduction to this gem</a> introduces each features of the gem clearly.</p>

<p>The <a href="https://github.com/MaxLap/activerecord_where_assoc/blob/master/README.md">gem’s README.md</a> contains known limitations and usage tips.</p>

<p><a href="https://github.com/MaxLap/activerecord_where_assoc/blob/master/EXAMPLES.md">Many examples</a> are available, including the generated SQL queries.</p>

<p>If you need extra convincing to try this gem, this document with the problems of the other ways of doing this kind of filtering should help: <a href="https://github.com/MaxLap/activerecord_where_assoc/blob/master/ALTERNATIVES_PROBLEMS.md">alternatives’ problems</a>.</p>

<h3 id="module-ActiveRecordWhereAssoc::RelationReturningMethods-label-Association">Association<span><a href="#module-ActiveRecordWhereAssoc::RelationReturningMethods-label-Association">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>The associations referred here are the links between your different models. They are your <code>#belongs_to</code>, <code>#has_many</code>, <code>#has_one</code>, <code>#has_and_belongs_to_many</code>.</p>

<p>This gem is about getting records from your database if their associations match (or don’t match) a certain condition (which by default is just to exist).</p>

<p>Every method here has an <strong>association_name</strong> parameter. This is the association you want to check if records exists.</p>

<pre class="ruby"><span class="ruby-comment"># Posts with at least one comment</span>
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">where_assoc_exists</span>(<span class="ruby-value">:comments</span>)

<span class="ruby-comment"># Posts with no comments</span>
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">where_assoc_not_exists</span>(<span class="ruby-value">:comments</span>)
</pre>

<p>If you want, you can pass an array of associations. They will be followed in order, just like a has_many :through would.</p>

<pre class="ruby"><span class="ruby-comment"># Posts which have at least one comment with a reply</span>
<span class="ruby-comment"># In other words: Posts which have at least one reply reachable through his comments</span>
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">where_assoc_exists</span>([<span class="ruby-value">:comments</span>, <span class="ruby-value">:replies</span>])
</pre>

<h3 id="module-ActiveRecordWhereAssoc::RelationReturningMethods-label-Condition">Condition<span><a href="#module-ActiveRecordWhereAssoc::RelationReturningMethods-label-Condition">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>After the <code>association_name</code> argument, you can pass conditions on your association to specify which of its records you care about. For example, you could only want Posts that have a comment marked as spam, so all you care about are comments marked as spam.</p>

<p>Another way to look at this is that you are filtering your association (using a <code>#where</code>) and checking if a record of that association is still found, and you do this for each of you records.</p>

<p>This <code>condition</code> argument is passed directly to <code>#where</code>, so you can pass in the following:</p>

<pre># Posts that have at least one comment considered as spam
# Using a Hash
Post.where_assoc_exists(:comments, is_spam: true)

# Using a String
Post.where_assoc_exists(:comments, &quot;is_spam = true&quot;)

# Using an Array (a string and its binds)
Post.where_assoc_exists(:comments, [&quot;is_spam = ?&quot;, true])

If the condition is blank, it is ignored (just like +#where+ does).</pre>

<p>Note, if you specify multiple associations using an Array, the conditions will only be applied to the last association.</p>

<pre class="ruby"><span class="ruby-comment"># Users which have a post that has a comment marked as spam.</span>
<span class="ruby-comment"># is_spam is only checked on the comment.</span>
<span class="ruby-constant">User</span>.<span class="ruby-identifier">where_assoc_exists</span>([<span class="ruby-value">:posts</span>, <span class="ruby-value">:comments</span>], <span class="ruby-value">is_spam:</span> <span class="ruby-keyword">true</span>)
</pre>

<p>If you want something else, you will need to use a block (see below) to nest multiple calls.</p>

<pre class="ruby"><span class="ruby-comment"># Users which have a post made in the last 5 days which has comments</span>
<span class="ruby-constant">User</span>.<span class="ruby-identifier">where_assoc_exists</span>(<span class="ruby-value">:posts</span>) {
  <span class="ruby-identifier">where</span>(<span class="ruby-string">&quot;created_at &gt; ?&quot;</span>, <span class="ruby-value">5</span>.<span class="ruby-identifier">days</span>.<span class="ruby-identifier">ago</span>).<span class="ruby-identifier">where_assoc_exists</span>(<span class="ruby-value">:comments</span>)
}
</pre>

<h3 id="module-ActiveRecordWhereAssoc::RelationReturningMethods-label-Block">Block<span><a href="#module-ActiveRecordWhereAssoc::RelationReturningMethods-label-Block">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>The block is used to add more complex conditions. The effect is the same as the condition parameter. You are specifying which records in the association you care about, but using a block lets you use any scoping methods, such as <code>#where</code>, <code>#joins</code>, nested <code>#where_assoc_*</code>, scopes on the model, etc.</p>

<p>Note that using <code>#joins</code> might lead to unexpected results when using <a href="RelationReturningMethods.html#method-i-where_assoc_count"><code>#where_assoc_count</code></a>, since if the joins adds rows, it will change the resulting count. It probably makes more sense to, again, use one of the <code>where_assoc_*</code> methods (they can be nested).</p>

<p>There are 2 ways of using the block for adding conditions to the association.</p>
<dl class="rdoc-list label-list"><dt>A block that receives one argument
<dd>
<p>The block receives a relation on the target association and return a relation with added filters or may return nil to do nothing.</p>

<pre class="ruby"><span class="ruby-comment"># These are all equivalent. Posts which have a comment marked as spam</span>
<span class="ruby-comment"># Using a where for the added condition</span>
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">where_assoc_exists</span>(<span class="ruby-value">:comments</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">comments_scope</span><span class="ruby-operator">|</span> <span class="ruby-identifier">comments_scope</span>.<span class="ruby-identifier">where</span>(<span class="ruby-value">is_spam:</span> <span class="ruby-keyword">true</span>) }

<span class="ruby-comment"># Applying a scope of the relation</span>
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">where_assoc_exists</span>(<span class="ruby-value">:comments</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">comments_scope</span><span class="ruby-operator">|</span> <span class="ruby-identifier">comments_scope</span>.<span class="ruby-identifier">spam_flagged</span> }

<span class="ruby-comment"># Applying a scope of the relation, using the &amp;:shortcut for procs</span>
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">where_assoc_exists</span>(<span class="ruby-value">:comments</span>, <span class="ruby-operator">&amp;</span><span class="ruby-value">:spam_flagged</span>)
</pre>
</dd><dt>A block that receives no argument
<dd>
<p>Instead of receiving the relation as argument, the relation is used as the “self” of the block. Everything else is identical to the block with one argument.</p>

<pre class="ruby"><span class="ruby-comment"># These are all equivalent. Posts which have a comment marked as spam</span>
<span class="ruby-comment"># Using a where for the added condition</span>
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">where_assoc_exists</span>(<span class="ruby-value">:comments</span>) { <span class="ruby-identifier">where</span>(<span class="ruby-value">is_spam:</span> <span class="ruby-keyword">true</span>) }

<span class="ruby-comment"># Applying a scope of the relation</span>
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">where_assoc_exists</span>(<span class="ruby-value">:comments</span>) { <span class="ruby-identifier">spam_flagged</span> }
</pre>
</dd></dl>

<p>The main reason to use a block with an argument instead of without one is when you need to call methods on the self outside of the block, such as:</p>

<pre class="ruby"><span class="ruby-constant">Post</span>.<span class="ruby-identifier">where_assoc_exists</span>(<span class="ruby-value">:comments</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">comments</span><span class="ruby-operator">|</span> <span class="ruby-identifier">comments</span>.<span class="ruby-identifier">where</span>(<span class="ruby-value">author_id:</span> <span class="ruby-identifier">foo</span>(<span class="ruby-value">:bar</span>)) }
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">where_assoc_exists</span>(<span class="ruby-value">:comments</span>) { <span class="ruby-operator">|</span><span class="ruby-identifier">comments</span><span class="ruby-operator">|</span> <span class="ruby-identifier">comments</span>.<span class="ruby-identifier">where</span>(<span class="ruby-value">author_id:</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">foo</span>(<span class="ruby-value">:bar</span>)) }
<span class="ruby-comment"># In both cases, using the version without arguments would not work, since the #foo</span>
<span class="ruby-comment"># would be called on the scope that was given to the block, instead of on the caller</span>
<span class="ruby-comment"># of the #where_assoc_exists method.</span>

<span class="ruby-comment"># THESE ARE WRONG!</span>
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">where_assoc_exists</span>(<span class="ruby-value">:comments</span>) { <span class="ruby-identifier">where</span>(<span class="ruby-value">author_id:</span> <span class="ruby-identifier">foo</span>(<span class="ruby-value">:bar</span>)) }
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">where_assoc_exists</span>(<span class="ruby-value">:comments</span>) { <span class="ruby-identifier">where</span>(<span class="ruby-value">author_id:</span> <span class="ruby-keyword">self</span>.<span class="ruby-identifier">foo</span>(<span class="ruby-value">:bar</span>)) }
<span class="ruby-comment"># THESE ARE WRONG!</span>
</pre>

<p>If both <code>condition</code> and <code>block</code> are given, the conditions are applied first, and then the block.</p>

<h3 id="module-ActiveRecordWhereAssoc::RelationReturningMethods-label-Options">Options<span><a href="#module-ActiveRecordWhereAssoc::RelationReturningMethods-label-Options">&para;</a> <a href="#top">&uarr;</a></span></h3>

<p>Some options are available to tweak how queries are generated. The default values of the options can be changed globally:</p>

<pre class="ruby"><span class="ruby-comment"># Somewhere in your setup code, such as an initializer in Rails</span>
<span class="ruby-constant">ActiveRecordWhereAssoc</span>.<span class="ruby-identifier">default_options</span>[<span class="ruby-value">:ignore_limit</span>] = <span class="ruby-keyword">true</span>
</pre>

<p>Or you can pass them as arguments after the <code>condition</code> argument.</p>

<pre class="ruby"><span class="ruby-constant">Post</span>.<span class="ruby-identifier">where_assoc_exists</span>(<span class="ruby-value">:comments</span>, <span class="ruby-string">&quot;is_spam = TRUE&quot;</span>, <span class="ruby-value">ignore_limit:</span> <span class="ruby-keyword">true</span>)
<span class="ruby-comment"># Because this is 2 consecutive hashes, must use the +{}+</span>
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">where_assoc_exists</span>(<span class="ruby-value">:comments</span>, {<span class="ruby-value">is_spam:</span> <span class="ruby-keyword">true</span>}, <span class="ruby-value">ignore_limit:</span> <span class="ruby-keyword">true</span>)
</pre>

<p>Note, if you don’t need a condition, you must pass nil as condition to provide options:</p>

<pre class="ruby"><span class="ruby-constant">Post</span>.<span class="ruby-identifier">where_assoc_exists</span>(<span class="ruby-value">:comments</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">ignore_limit:</span> <span class="ruby-keyword">true</span>)
</pre>

<h5 id="module-ActiveRecordWhereAssoc::RelationReturningMethods-label-3Aignore_limit+option">:ignore_limit option<span><a href="#module-ActiveRecordWhereAssoc::RelationReturningMethods-label-3Aignore_limit+option">&para;</a> <a href="#top">&uarr;</a></span></h5>

<p>When true, <code>#limit</code> and <code>#offset</code> that are set from default_scope, on associations, and from <code>#has_one</code> are ignored. <br> Removing the limit from <code>#has_one</code> makes them be treated like a <code>#has_many</code>.</p>

<p>Main reasons to use ignore_limit: true</p>
<ul><li>
<p>Needed for MySQL to be able to do anything with <code>#has_one</code> associations because MySQL doesn’t support sub-limit. <br> See <a href="https://github.com/MaxLap/activerecord_where_assoc#mysql-doesnt-support-sub-limit">MySQL doesn’t support limit</a> <br> Note, this does mean the <code>#has_one</code> will be treated as if it was a <code>#has_many</code> for MySQL too.</p>
</li><li>
<p>You have a <code>#has_one</code> association which you know can never have more than one record and are dealing with a heavy/slow query. The query used to deal with <code>#has_many</code> is less complex, and may prove faster.</p>
</li><li>
<p>For this one special case, you want to check the other records that match your has_one</p>
</li></ul>

<h5 id="module-ActiveRecordWhereAssoc::RelationReturningMethods-label-3Anever_alias_limit+option">:never_alias_limit option<span><a href="#module-ActiveRecordWhereAssoc::RelationReturningMethods-label-3Anever_alias_limit+option">&para;</a> <a href="#top">&uarr;</a></span></h5>

<p>When true, <code>#where_assoc_*</code> will not use <code>#from</code> to build relations that have <code>#limit</code> or <code>#offset</code> set on default_scope or on associations or for <code>#has_one</code>. <br> This allows changing the from as part of the conditions (such as for a scope)</p>

<p>Main reasons to use this: you have to use <code>#from</code> in the block of <code>#where_assoc_*</code> method (ex: because a scope needs <code>#from</code>).</p>

<p>Why this isn’t the default:</p>
<ul><li>
<p>From very few tests, the aliasing way seems to produce better plans.</p>
</li><li>
<p>Using aliasing produces a shorter query.</p>
</li></ul>

<h5 id="module-ActiveRecordWhereAssoc::RelationReturningMethods-label-3Apoly_belongs_to+option">:poly_belongs_to option<span><a href="#module-ActiveRecordWhereAssoc::RelationReturningMethods-label-3Apoly_belongs_to+option">&para;</a> <a href="#top">&uarr;</a></span></h5>

<p>Specify what to do when a polymorphic belongs_to is encountered. Things are tricky because the query can end up searching in multiple Models, and just knowing which ones to look into can require an expensive query. It’s also possible that you only want to search for those that match some specific Models, ignoring the other ones.</p>
<dl class="rdoc-list label-list"><dt>:pluck
<dd>
<p>Do a <code>#pluck</code> in the column to detect to possible choices. This option can have a performance cost for big tables or when the query if done often, as the <code>#pluck</code> will be executed each time. It is important to note that this happens when the query is prepared, so using this with methods that return SQL (such as <a href="SqlReturningMethods.html#method-i-assoc_exists_sql"><code>SqlReturningMethods#assoc_exists_sql</code></a>) will still execute a query even if you don’t use the returned string.</p>
</dd><dt>model or array of models
<dd>
<p>Specify which models to search for. This avoids the performance cost of <code>#pluck</code> and can allow to filter some of the choices out that don’t interest you. <br> Note, these are not instances, it’s actual models, ex: <code>[Post, Comment]</code></p>
</dd><dt>a hash
<dd>
<p>The keys must be models (same behavior as an array of models). <br> The values are conditions to apply only for key’s model. The conditions are either a proc (behaves like the block, but only for that model) or the same things <code>#where</code> can receive. (String, Hash, Array, nil). Ex:</p>

<pre class="ruby"><span class="ruby-constant">List</span>.<span class="ruby-identifier">where_assoc_exists</span>(<span class="ruby-value">:items</span>, <span class="ruby-keyword">nil</span>, <span class="ruby-value">poly_belongs_to:</span> {<span class="ruby-constant">Car</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-string">&quot;color = &#39;blue&#39;&quot;</span>,
                                                       <span class="ruby-constant">Computer</span> <span class="ruby-operator">=&gt;</span> <span class="ruby-identifier">proc</span> { <span class="ruby-identifier">brand_new</span>.<span class="ruby-identifier">where</span>(<span class="ruby-value">core:</span> <span class="ruby-value">4</span>) } })
</pre>
</dd><dt>:raise
<dd>
<p>(default) raise an exception when a polymorphic belongs_to is encountered.</p>
</dd></dl>

  </section>

  <section id="5Buntitled-5D" class="documentation-section">





  </section>
  <section id="Basic+methods" class="documentation-section">
    <header class="documentation-section-title">
      <h2>
        Basic methods
      </h2>
      <span class="section-click-top">
        <a href="#top">&uarr; top</a>
      </span>
    </header>





     <section id="public-instance-Basic+methods-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

      <div id="method-i-where_assoc_exists" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">where_assoc_exists</span><span
              class="method-args">(association_name, conditions = nil, options = {}, &amp;block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a new relation with a condition added (a <code>#where</code>) that checks if an association of the model exists. Extra conditions the associated model must match can also be specified.</p>

<p>You could say this is a way of doing a <code>#select</code> that uses associations of your model on the SQL side, but faster and more concise.</p>

<p>Examples (with an equivalent ruby <code>#select</code>)</p>

<pre class="ruby"><span class="ruby-comment"># Posts that have comments</span>
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">where_assoc_exists</span>(<span class="ruby-value">:comments</span>)
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">all</span>.<span class="ruby-identifier">select</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">post</span><span class="ruby-operator">|</span> <span class="ruby-identifier">post</span>.<span class="ruby-identifier">comments</span>.<span class="ruby-identifier">exists?</span> }

<span class="ruby-comment"># Posts that have comments marked as spam</span>
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">where_assoc_exists</span>(<span class="ruby-value">:comments</span>, <span class="ruby-value">is_spam:</span> <span class="ruby-keyword">true</span>)
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">select</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">post</span><span class="ruby-operator">|</span> <span class="ruby-identifier">post</span>.<span class="ruby-identifier">comments</span>.<span class="ruby-identifier">any?</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">comment</span><span class="ruby-operator">|</span> <span class="ruby-identifier">comment</span>.<span class="ruby-identifier">is_spam</span> } }

<span class="ruby-comment"># Posts that have comments that have replies</span>
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">where_assoc_exists</span>([<span class="ruby-value">:comments</span>, <span class="ruby-value">:replies</span>])
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">select</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">post</span><span class="ruby-operator">|</span> <span class="ruby-identifier">post</span>.<span class="ruby-identifier">comments</span>.<span class="ruby-identifier">any?</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">comment</span><span class="ruby-operator">|</span> <span class="ruby-identifier">comment</span>.<span class="ruby-identifier">replies</span>.<span class="ruby-identifier">exists?</span> } }
</pre>
<dl class="rdoc-list label-list"><dt>association_name
<dd>
<p>The association that must exist <br> See <a href="RelationReturningMethods.html#module-ActiveRecordWhereAssoc::RelationReturningMethods-label-Association">Association at <code>RelationReturningMethods</code></a></p>
</dd><dt>condition
<dd>
<p>Extra conditions the association must match <br> See <a href="RelationReturningMethods.html#module-ActiveRecordWhereAssoc::RelationReturningMethods-label-Condition">Condition at <code>RelationReturningMethods</code></a></p>
</dd><dt>options
<dd>
<p>Options to alter the generated query <br> See <a href="RelationReturningMethods.html#module-ActiveRecordWhereAssoc::RelationReturningMethods-label-Options">Options at <code>RelationReturningMethods</code></a></p>
</dd><dt>&amp;block
<dd>
<p>More complex conditions the associated record must match (can also use scopes of the association’s model) <br> See <a href="RelationReturningMethods.html#module-ActiveRecordWhereAssoc::RelationReturningMethods-label-Block">Block at <code>RelationReturningMethods</code></a></p>
</dd></dl>

<p>You can get the SQL string of the condition using <a href="SqlReturningMethods.html#method-i-assoc_exists_sql"><code>SqlReturningMethods#assoc_exists_sql</code></a>.</p>

          <div class="method-source-code" id="where_assoc_exists-source">
            <pre><span class="ruby-comment"># File lib/active_record_where_assoc/relation_returning_methods.rb, line 255</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">where_assoc_exists</span>(<span class="ruby-identifier">association_name</span>, <span class="ruby-identifier">conditions</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">options</span> = {}, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">sql</span> = <span class="ruby-constant">ActiveRecordWhereAssoc</span><span class="ruby-operator">::</span><span class="ruby-constant">CoreLogic</span>.<span class="ruby-identifier">assoc_exists_sql</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">klass</span>, <span class="ruby-identifier">association_name</span>, <span class="ruby-identifier">conditions</span>, <span class="ruby-identifier">options</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">where</span>(<span class="ruby-identifier">sql</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

      <div id="method-i-where_assoc_not_exists" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">where_assoc_not_exists</span><span
              class="method-args">(association_name, conditions = nil, options = {}, &amp;block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a new relation with a condition added (a <code>#where</code>) that checks if an association of the model does not exist. Extra conditions the associated model that exists must not match can also be specified.</p>

<p>This the exact opposite of what <a href="RelationReturningMethods.html#method-i-where_assoc_exists"><code>#where_assoc_exists</code></a> does, so a <a href="RelationReturningMethods.html#method-i-where_assoc_not_exists"><code>#where_assoc_not_exists</code></a> with the same arguments will keep every records that were rejected by the <a href="RelationReturningMethods.html#method-i-where_assoc_exists"><code>#where_assoc_exists</code></a>.</p>

<p>You could say this is a way of doing a <code>#reject</code> that uses associations of your model on the SQL side, but faster and more concise.</p>

<p>Examples (with an equivalent ruby <code>#reject</code>)</p>

<pre class="ruby"><span class="ruby-comment"># Posts that have no comments</span>
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">where_assoc_not_exists</span>(<span class="ruby-value">:comments</span>)
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">all</span>.<span class="ruby-identifier">reject</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">post</span><span class="ruby-operator">|</span> <span class="ruby-identifier">post</span>.<span class="ruby-identifier">comments</span>.<span class="ruby-identifier">exists?</span> }

<span class="ruby-comment"># Posts that don&#39;t have comments marked as spam (but might have unmarked comments)</span>
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">where_assoc_not_exists</span>(<span class="ruby-value">:comments</span>, <span class="ruby-value">is_spam:</span> <span class="ruby-keyword">true</span>)
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">reject</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">post</span><span class="ruby-operator">|</span> <span class="ruby-identifier">post</span>.<span class="ruby-identifier">comments</span>.<span class="ruby-identifier">any?</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">comment</span><span class="ruby-operator">|</span> <span class="ruby-identifier">comment</span>.<span class="ruby-identifier">is_spam</span> } }

<span class="ruby-comment"># Posts that don&#39;t have comments that have replies (but can have comments that have no replies)</span>
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">where_assoc_exists</span>([<span class="ruby-value">:comments</span>, <span class="ruby-value">:replies</span>])
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">reject</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">post</span><span class="ruby-operator">|</span> <span class="ruby-identifier">post</span>.<span class="ruby-identifier">comments</span>.<span class="ruby-identifier">any?</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">comment</span><span class="ruby-operator">|</span> <span class="ruby-identifier">comment</span>.<span class="ruby-identifier">replies</span>.<span class="ruby-identifier">exists?</span> } }
</pre>
<dl class="rdoc-list label-list"><dt>association_name
<dd>
<p>The association that must exist <br> See <a href="RelationReturningMethods.html#module-ActiveRecordWhereAssoc::RelationReturningMethods-label-Association">Association at <code>RelationReturningMethods</code></a></p>
</dd><dt>condition
<dd>
<p>Extra conditions the association must not match <br> See <a href="RelationReturningMethods.html#module-ActiveRecordWhereAssoc::RelationReturningMethods-label-Condition">Condition at <code>RelationReturningMethods</code></a></p>
</dd><dt>options
<dd>
<p>Options to alter the generated query <br> See <a href="RelationReturningMethods.html#module-ActiveRecordWhereAssoc::RelationReturningMethods-label-Options">Options at <code>RelationReturningMethods</code></a></p>
</dd><dt>&amp;block
<dd>
<p>More complex conditions the associated record must match (can also use scopes of the association’s model) <br> See <a href="RelationReturningMethods.html#module-ActiveRecordWhereAssoc::RelationReturningMethods-label-Block">Block at <code>RelationReturningMethods</code></a></p>
</dd></dl>

<p>You can get the SQL string of the condition using <a href="SqlReturningMethods.html#method-i-assoc_not_exists_sql"><code>SqlReturningMethods#assoc_not_exists_sql</code></a>.</p>

          <div class="method-source-code" id="where_assoc_not_exists-source">
            <pre><span class="ruby-comment"># File lib/active_record_where_assoc/relation_returning_methods.rb, line 301</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">where_assoc_not_exists</span>(<span class="ruby-identifier">association_name</span>, <span class="ruby-identifier">conditions</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">options</span> = {}, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">sql</span> = <span class="ruby-constant">ActiveRecordWhereAssoc</span><span class="ruby-operator">::</span><span class="ruby-constant">CoreLogic</span>.<span class="ruby-identifier">assoc_not_exists_sql</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">klass</span>, <span class="ruby-identifier">association_name</span>, <span class="ruby-identifier">conditions</span>, <span class="ruby-identifier">options</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">where</span>(<span class="ruby-identifier">sql</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

    </section>

  </section>
  <section id="Complex+method" class="documentation-section">
    <header class="documentation-section-title">
      <h2>
        Complex method
      </h2>
      <span class="section-click-top">
        <a href="#top">&uarr; top</a>
      </span>
    </header>





     <section id="public-instance-Complex+method-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

      <div id="method-i-where_assoc_count" class="method-detail ">
        <div class="method-header">
          <div class="method-heading">
            <span class="method-name">where_assoc_count</span><span
              class="method-args">(left_operand, operator, association_name, conditions = nil, options = {}, &amp;block)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
        </div>

        <div class="method-description">
          <p>Returns a new relation with a condition added (a <code>#where</code>) that checks how many records an association of the model has. Extra conditions the associated model must match can also be specified.</p>

<p>This method is a generalization of <a href="RelationReturningMethods.html#method-i-where_assoc_exists"><code>#where_assoc_exists</code></a> and <a href="RelationReturningMethods.html#method-i-where_assoc_not_exists"><code>#where_assoc_not_exists</code></a>. It does the same thing, but can be more precise over how many records should exist (and match the extra conditions) To clarify, here are equivalent examples:</p>

<pre class="ruby"><span class="ruby-constant">Post</span>.<span class="ruby-identifier">where_assoc_exists</span>(<span class="ruby-value">:comments</span>)
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">where_assoc_count</span>(<span class="ruby-value">1</span>, <span class="ruby-value">:&lt;=</span>, <span class="ruby-value">:comments</span>)

<span class="ruby-constant">Post</span>.<span class="ruby-identifier">where_assoc_not_exists</span>(<span class="ruby-value">:comments</span>)
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">where_assoc_count</span>(<span class="ruby-value">0</span>, <span class="ruby-value">:==</span>, <span class="ruby-value">:comments</span>)
</pre>

<p>But these have no equivalent:</p>

<pre class="ruby"><span class="ruby-comment"># Posts with at least 5 comments</span>
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">where_assoc_count</span>(<span class="ruby-value">5</span>, <span class="ruby-value">:&lt;=</span>, <span class="ruby-value">:comments</span>)

<span class="ruby-comment"># Posts with less than 5 comments</span>
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">where_assoc_count</span>(<span class="ruby-value">5</span>, <span class="ruby-value">:&gt;</span>, <span class="ruby-value">:comments</span>)
</pre>

<p>You could say this is a way of doing a <code>#select</code> that <code>#count</code> the associations of your model on the SQL side, but faster and more concise.</p>

<p>Examples (with an equivalent ruby <code>#select</code> and <code>#count</code>)</p>

<pre class="ruby"><span class="ruby-comment"># Posts with at least 5 comments</span>
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">where_assoc_count</span>(<span class="ruby-value">5</span>, <span class="ruby-value">:&lt;=</span>, <span class="ruby-value">:comments</span>)
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">all</span>.<span class="ruby-identifier">select</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">post</span><span class="ruby-operator">|</span> <span class="ruby-identifier">post</span>.<span class="ruby-identifier">comments</span>.<span class="ruby-identifier">count</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">5</span> }

<span class="ruby-comment"># Posts that have at least 5 comments marked as spam</span>
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">where_assoc_count</span>(<span class="ruby-value">5</span>, <span class="ruby-value">:&lt;=</span>, <span class="ruby-value">:comments</span>, <span class="ruby-value">is_spam:</span> <span class="ruby-keyword">true</span>)
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">all</span>.<span class="ruby-identifier">select</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">post</span><span class="ruby-operator">|</span> <span class="ruby-identifier">post</span>.<span class="ruby-identifier">comments</span>.<span class="ruby-identifier">where</span>(<span class="ruby-value">is_spam:</span> <span class="ruby-keyword">true</span>).<span class="ruby-identifier">count</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">5</span> }

<span class="ruby-comment"># Posts that have at least 10 replies spread over their comments</span>
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">where_assoc_count</span>(<span class="ruby-value">10</span>, <span class="ruby-value">:&lt;=</span>, [<span class="ruby-value">:comments</span>, <span class="ruby-value">:replies</span>])
<span class="ruby-constant">Post</span>.<span class="ruby-identifier">select</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">post</span><span class="ruby-operator">|</span> <span class="ruby-identifier">post</span>.<span class="ruby-identifier">comments</span>.<span class="ruby-identifier">sum</span> { <span class="ruby-operator">|</span><span class="ruby-identifier">comment</span><span class="ruby-operator">|</span> <span class="ruby-identifier">comment</span>.<span class="ruby-identifier">replies</span>.<span class="ruby-identifier">count</span> } <span class="ruby-operator">&gt;=</span> <span class="ruby-value">5</span> }
</pre>
<dl class="rdoc-list label-list"><dt>left_operand
<dd>
<p>1st argument, the left side of the comparison. <br> One of:</p>
<ul><li>
<p>a number</p>
</li><li>
<p>a string of SQL to embed in the query</p>
</li><li>
<p>a range (operator must be :== or :!=), will use BETWEEN or NOT BETWEEN<br> supports infinite ranges and exclusive end</p>

<p># Posts with 5 to 10 comments Post.where_assoc_count(5..10, :==, :comments)</p>

<p># Posts with less than 5 or more than 10 comments Post.where_assoc_count(5..10, :!=, :comments)</p>
</li></ul>
</dd><dt>operator
<dd>
<p>The operator to use, one of these symbols: <code>  :&lt;  :&lt;=  :==  :!=  :&gt;=  :&gt;  </code></p>
</dd><dt>association_name
<dd>
<p>The association that must have a certain number of occurrences <br> Note that if you use an array of association names, the number of the last association is what is counted.</p>

<pre class="ruby"><span class="ruby-comment"># Users which have received at least 5 comments total (can be spread on all of their posts)</span>
<span class="ruby-constant">User</span>.<span class="ruby-identifier">where_assoc_count</span>(<span class="ruby-value">5</span>, <span class="ruby-value">:&lt;=</span>, [<span class="ruby-value">:posts</span>, <span class="ruby-value">:comments</span>])
</pre>

<p>See <a href="RelationReturningMethods.html#module-ActiveRecordWhereAssoc::RelationReturningMethods-label-Association">Association at <code>RelationReturningMethods</code></a></p>
</dd><dt>condition
<dd>
<p>Extra conditions the association must match to count <br> See <a href="RelationReturningMethods.html#module-ActiveRecordWhereAssoc::RelationReturningMethods-label-Condition">Condition at <code>RelationReturningMethods</code></a></p>
</dd><dt>options
<dd>
<p>Options to alter the generated query <br> See <a href="RelationReturningMethods.html#module-ActiveRecordWhereAssoc::RelationReturningMethods-label-Options">Options at <code>RelationReturningMethods</code></a></p>
</dd><dt>&amp;block
<dd>
<p>More complex conditions the associated record must match (can also use scopes of the association’s model) <br> See <a href="RelationReturningMethods.html#module-ActiveRecordWhereAssoc::RelationReturningMethods-label-Block">Block at <code>RelationReturningMethods</code></a></p>
</dd></dl>

<p>The order of the parameters may seem confusing. But you will get used to it. It helps to remember that the goal is to do:</p>

<pre>5 &lt; (SELECT COUNT(*) FROM ...)</pre>

<p>So the parameters are in the same order as in that query: number, operator, association.</p>

<p>To be clear, when you use multiple associations in an array, the count you will be comparing against is the total number of records of that last association.</p>

<pre class="ruby"><span class="ruby-comment"># The users that have received at least 5 comments total on all of their posts</span>
<span class="ruby-comment"># So this can be from one post that has 5 comments of from 5 posts with 1 comments</span>
<span class="ruby-constant">User</span>.<span class="ruby-identifier">where_assoc_count</span>(<span class="ruby-value">5</span>, <span class="ruby-value">:&lt;=</span>, [<span class="ruby-value">:posts</span>, <span class="ruby-value">:comments</span>])

<span class="ruby-comment"># The users that have at least 5 posts with at least one comments</span>
<span class="ruby-constant">User</span>.<span class="ruby-identifier">where_assoc_count</span>(<span class="ruby-value">5</span>, <span class="ruby-value">:&lt;=</span>, <span class="ruby-value">:posts</span>) { <span class="ruby-identifier">where_assoc_exists</span>(<span class="ruby-value">:comments</span>) }
</pre>

<p>You can get the SQL string of the condition using <a href="SqlReturningMethods.html#method-i-compare_assoc_count_sql"><code>SqlReturningMethods#compare_assoc_count_sql</code></a>. You can get the SQL string for only the counting using <a href="SqlReturningMethods.html#method-i-only_assoc_count_sql"><code>SqlReturningMethods#only_assoc_count_sql</code></a>.</p>

          <div class="method-source-code" id="where_assoc_count-source">
            <pre><span class="ruby-comment"># File lib/active_record_where_assoc/relation_returning_methods.rb, line 402</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier ruby-title">where_assoc_count</span>(<span class="ruby-identifier">left_operand</span>, <span class="ruby-identifier">operator</span>, <span class="ruby-identifier">association_name</span>, <span class="ruby-identifier">conditions</span> = <span class="ruby-keyword">nil</span>, <span class="ruby-identifier">options</span> = {}, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">sql</span> = <span class="ruby-constant">ActiveRecordWhereAssoc</span><span class="ruby-operator">::</span><span class="ruby-constant">CoreLogic</span>.<span class="ruby-identifier">compare_assoc_count_sql</span>(<span class="ruby-keyword">self</span>.<span class="ruby-identifier">klass</span>, <span class="ruby-identifier">left_operand</span>, <span class="ruby-identifier">operator</span>,
                                                                  <span class="ruby-identifier">association_name</span>, <span class="ruby-identifier">conditions</span>, <span class="ruby-identifier">options</span>, <span class="ruby-operator">&amp;</span><span class="ruby-identifier">block</span>)
  <span class="ruby-identifier">where</span>(<span class="ruby-identifier">sql</span>)
<span class="ruby-keyword">end</span></pre>
          </div>
        </div>


      </div>

    </section>

  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.6.3.1.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

